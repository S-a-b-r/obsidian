09.09.2024 14:28
Tags: #info

---
# in-memory db

In-memory data bases или как их еще называют "Резидентные Базы данных" - это базы, которые весь объем данных хранят целиком в оперативной памяти. Размер такой базы лимитирован емкостью оперативной памяти узла, что может ограничивать нас в количестве данных, но на порядок увеличивают скорость работы с ними.
Но это вовсе не означает, что если оперативная память закончится, то информация перестанет записываться. Современные in-memory DB спроектированы таким образом, что если данных слишком много, БД сохраняют данные на диск. Поэтому стереотип про ненадежность БД в памяти сильно устарел.

Отсюда вывод, БД в памяти нужны для высокой скорости доступа к данным, условно от 10 000 запросов в секунду.

Как примеры таких БД можно рассмотреть [[Redis]] и [[Tarantool]]. 

## Где нам нужна такая скорость доступа к данным?

### Кеш
БД в памяти традиционно используют как кеш для более медленных баз данных. Это логично, ведь память быстрее диска, даже SSD. Но в жизненном цикле любого кеша случаются перезагрузки, падения, сетевая недоступность и прочие инфраструктурные беды.
Поэтому с течением времени кеши стали уметь в [[Парсистентность]], [[Резервирование]] и [[Шардирование]].

### OLTP
Расшифровывается как Online Transaction Processing, обработка транзакций в реальном времени. In-memory решения подходят для такого типа задач благодаря своей архитектуре. OLTP — это большое количество коротких on-line транзакций (INSERT, UPDATE, DELETE). Главное в OLTP-системах — быстро обработать запросы и обеспечить целостность данных. Эффективность чаще всего определяется количеством RPS.

## Технические особенности (Различия Redis и Tarantool)

### Какие типы данных можно хранить
В Redis ключом может быть только строка. В Redis можно хранить и манипулировать следующими типами данных:  
  - строки;
- списки строк;
- неупорядоченные множества строк;
- хешмапы или просто строковые пары ключ-значение;
- упорядоченные множества строк;
- Bitmap и HyperLogLog.

В Tarantool можно хранить и манипулировать следующими типами данных:  
- Атомарными:  
    - строки;
    - логический тип (истина, ложь);
    - целочисленный;
    - с плавающей запятой;
    - с десятичной плавающей запятой;
    - UUID.
- Комплексными:  
    - массивы;
    - хешмапы.

Типы данных Redis лучше подходят для счётчиков событий, в том числе уникальных, для хранения небольших готовых витрин данных. А типы данных Tarantool лучше подходят для хранения объектов и/или документов, как в SQL и NoSQL СУБД.

### Вытеснение данных
Redis и Tarantool содержат в себе механизм ограничения занимаемой памяти. Когда клиент попытается добавить ещё данные, когда лимит уже был исчерпан, базы ответят ошибкой. И Redis, и Tarantool в этой ситуации продолжат выполнять запросы на чтение.  
Перейдём к другому механизму, когда мы можем настроить алгоритм удаления «больше ненужных» данных. **Redis** содержит в себе несколько механизмов вытеснения:  
  

- TTL — вытеснение объектов по завершении срока жизни;
- LRU — вытеснение **давно использованных** данных;
- RANDOM — вытеснение случайно попавшихся под руку объектов;
- LFU — вытеснение **редко используемых** данных.

Все механизмы могут быть настроены либо на весь объем данных, либо только на те объекты, которые помечены как вытесняемые.  
  
В **Tarantool** для вытеснения данных можно использовать расширения expirationd или indexpiration, или создать собственную фоновую процедуру, которая будет проходить по индексу (например, с таймштампом) и удалять ненужные данные.

### Итерация по ключам
В **Redis** можно это сделать с помощью операторов:  
- `SCAN`;
- итерация по ключам.
Операции возвращают страницы с результатами. Для получения каждой новой страницы, необходимо передать «идентификатор» предыдущей. Операции поддерживают фильтрацию по шаблону. Для этого используется параметр `MATCH`. Фильтрация происходит на момент выдачи страницы, поэтому некоторые страницы могут оказаться пустыми. Это не будет означать, что страниц больше не осталось.  
  
В **Tarantool** доступна гибкая схема итерации по ключам. Можно итерироваться в прямом и обратном направлении. В процессе можно дополнительно фильтровать значения. Можно сместиться на определённое значение ключа, затем проходить по следующим ключам в сторону возрастания или убывания. Направление прохода на лету менять нельзя.  
  
Например:  
```
results = {}for _, tuple in box.space.pairs('key', 'GE') do    if tuple['value'] > 10 then        table.insert(results, tuple)  endendreturn results
```

### Вторичные индексы
**Redis**    
У Redis нет вторичных индексов. Есть некоторые трюки, чтобы их имитировать:  
  - В упорядоченных множествах можно использовать порядковый номер элемента как вторичный ключ.
- Использовать хешмапы, ключ которых является, в некотором смысле, индексом данных.

**Tarantool**  
  В Tarantool можно строить произвольное количество вторичных индексов для данных:  
  - Вторичные ключи могут состоять из нескольких полей.
  - Для вторичных индексов можно использовать типы `HASH`, `TREE`, `RTREE`, `BITSET`.
  - Вторичные индексы могут содержать уникальные и не уникальные ключи.
  - У любых индексов можно использовать настройки локали, например, для регистронезависимых строковых значений.
  - Вторичные индексы могут строиться по полям с массивом значений (иногда их называют мультииндексы).

### Транзакции

Механизм транзакций позволяет выполнить несколько операций атомарно. И Redis, и Tarantool поддерживают транзакции. Пример транзакции в Redis:  
```
> MULTIOK> INCR fooQUEUED> INCR barQUEUED> EXEC1) (integer) 12) (integer) 1
```

Пример транзакции в Tarantool:  
```
do  box.begin()  box.space.kv:update('foo', {{'+', 'value', 1}})  box.space.kv:update('bar', {{'+', 'value', 1}})  box.commit()end
```

### Персистентность

Персистентность данных обеспечивается двумя механизмами:  
- периодическим сбросом in-memory данных на диск — snapshoting;
- последовательной упреждающей записью всех приходящих операций в файл — transaction journal.

И Redis, и Tarantool содержат оба механизма персистентности.  
  
**Redis**    
Redis периодически сбрасывает все данные из памяти на диск. Происходит это по-умолчанию каждые 60 секунд (настраивается). Redis использует механизм ОС fork для «копирования» текущих данных в памяти, затем информация сохраняется на диск. Если происходит аварийное завершение, то Redis восстановит состояние из последнего сохранения. Если последний снапшот был сделан давно, то данные, пришедшие после снапшота, будут утеряны.  
  
Журнал операций используется для сохранения всей приходящей в базу информации. Каждая операция сохраняется в журнал на диске. Так, при запуске Redis восстанавливает своё состояние из снапшота и затем донакатывает оставшиеся транзакции из журнала.  
  
  - Снапшот в Redis называется RDB (redis database).
- Журнал операций в Redis называется AOF (append only file).

  
**Tarantool** 
  
- Механизм персистентности взят из архитектур баз данных.
- Он является целостным — снапшоты и журналирование.
- Этот же механизм позволяет существовать надежной WAL-based репликации.

Tarantool периодически сохраняет текущие in-memory данные на диск и записывает каждую операцию в журнал.  
  - Снапшот в Tarantool называется snap (snapshot). Можно делать с произвольной частотой.
- Журнал транзакций в Tarantool называется WAL (write ahead log).

  И в Redis, и в Tarantool каждый из механизмов может быть выключен. Для надёжного хранения данных оба механизма надо включить. Для максимального быстродействия можно отключить снапшотинг и журналирование, заплатив персистентностью. Слабоумие и отвага!

### Troubleshooting  
  
Если повреждён файл журнала в Redis:  
  

```
redis-check-aof --fix
```

  
Если повреждён файл журнала в Tarantool:  
  

```
tarantool> box.cfg{force_recovery=true}
```

### Язык программирования для хранимых процедур

Хранимые процедуры — это код, выполняющийся рядом с данными. И Redis, и Tarantool предлагают Lua для создания хранимок. С точки зрения пользователя это очень простой язык. Он создавался для людей, для которых программирование будет инструментом решения задач в предметной области.  
  
C точки зрения разработчика базы данных:  
  - Lua — это язык, который легко встраивается в существующее приложение.
- Он просто интегрируется с объектами и процессами приложения.
- Lua имеет динамическую типизацию и автоматическое управление памятью.
- Язык имеет сборщик мусора incremental Mark&Sweep.

**Таймаут задач**  
- В Redis можно задать таймаут, после которого выполнение хранимой процедуры прервётся.
- В Tarantool хранимые процедуры компилируются и выполняются быстрее, но в этом механизме нет возможности выставить таймаут. Для прерывания хранимой процедуры пользователь должен предусмотреть механизм проверки флага прерывания.

**Runtime**  
- В Redis используется однозадачность: задачи выполняются по одной и целиком.
- В Tarantool используется кооперативная многозадачность. Задачи выполняются по одной, но при этом задача отдаёт управление на операциях ввода-вывода или явно с помощью yield.

### Репликация
Репликация — это механизм копирования объектов с одного узла на другой. Бывает асинхронная и синхронная.  
  
- Асинхронная репликация: при вставке объекта на один узел мы не дожидаемся, когда этот же объект будет отреплицирован на второй узел.
- Синхронная репликация: при вставке объекта мы дожидаемся, когда он будет сохранён на первом и втором узлах.

И Redis, и Tarantool поддерживают асинхронную репликацию. Только Tarantool умеет в синхронную репликацию.  
  
  На практике бывают ситуации, когда мы хотим дождаться репликации объекта. И в Redis, и в Tarantool есть способы для этого:  
  
- В Redis это команда wait. Она принимает два параметра:  
    
    - сколько реплик должны получить объект;
    - сколько ждать, пока это произойдёт.

- В Tarantool это можно сделать фрагментом кода:

  псевдокод:  
```
while not timeout do    if box.info.lsn <= (box.info.replication[dst].downstream.vclock[box.info.id] or 0) then        break    end    fiber.sleep(0.1)end
```

  
**Синхронная репликация**  
В Redis нет синхронной репликации. Начиная с Tarantool 2.6 синхронная репликация доступна.


---
### Zero-links:
[[00 Backend]]

---
### Links: