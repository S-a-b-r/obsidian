07.07.2024 14:08
Tags: #info

---
# Структуры
Аналог классов в других языках программирования. Поля структуры могут быть любого типа, даже указателями на структуру. Классический пример, дерево: 
```go
type Tree struct {
    Value      int
    LeftChild  *Tree
    RightChild *Tree
}
```

## Инициализация
1. Пустой объект
```go
p := Person{}
// или
var p Person
```
2. Неявное указание значений поля
```go
date := time.Date(2000, 12, 1, 0, 0, 0, 0, time.UTC)
p := Person{"Иван", "ivan@yandex.ru", date}
```
Требования:
- Нужно перечислить все поля объекта.
- Порядок следования аргументов инициализатора должен совпадать с порядком описания полей структуры. Если поставить поле `Email` на первое место в описании `type Person struct`, инициализация экземпляра выше будет некорректна (с точки зрения логики, но не компилятора).

Подход применяют:

- когда нужно явно указать значения всех полей объекта;
- когда вы уверены, что спецификация типа не будет меняться часто, иначе придётся вносить правки для каждого инициализатора объекта в коде.
3. Явное указание значений полей:
```go
p := Person{Name: "Иван", Email: "ivan@yandex.ru"}
```
При таком подходе явно указывают имена полей и их значения.

Особенности:

- этот подход отличается от второго опциональным указанием полей;
- порядок указания полей не важен;
- значения полей, которые не были использованы в инициализаторе (`dateOfBirth` в примере), примут значения по умолчанию.
4. Конструктор
Учитывая тонкости при инициализации сложного объекта, разработчики иногда применяют конструкторы. В Go нет специальной конструкции для этого, поэтому зачастую можно встретить что-то такое:
```go
   func NewPerson(name, email string, dobYear, dobMonth, dobDay int) Person {
       return Person{
           Name:        name,
           Email:       email,
           dateOfBirth: time.Date(dobYear, time.Month(dobMonth), dobDay, 0, 0, 0, 0, time.UTC),
       }
   }
```
Вот некоторые правила, одобренные Go-сообществом:

- имя функции конструктора пишут с префиксом `New`;
- если конструктор производит валидацию аргументов, функция должна возвращать ошибку последним аргументом.

Можем вернуться к нашему примеру, чтобы добавить проверку корректности `email` и числовых компонент даты, тогда декларация функции примет вид:
```go
func NewPerson(name, email string, dobYear, dobMonth, dobDay int) (Person, error) {} 
```

Подход применяют:
- когда нужно производить валидацию аргументов, чтобы построить логически правильный объект;
- когда построение экземпляра объекта требует дополнительных действий, например, подключения к базе данных.

## Доступ к полям
Для доступа к полям структуры используется точка (`p.Name`):
```go
p := NewPerson("Иван", "ivan@yandex.ru", 2000, 12, 1)
fmt.Println(p.Name, p.Email)

p.Name = "Пётр"
fmt.Println(p.Name) 
```

## Теги

У каждого поля структуры может быть набор аннотаций, которые называются **тегами (tags)**:

```go
type GetUserRequest struct {
    UserId string `json:"user_id" yaml: "user_id" format:"uuid" example:"2e263a90-b74b-11eb-8529-0242ac130003"`
    IsDeleted *bool `json:"is_deleted,omitempty" yaml:"is_deleted"`
} 
```

`json:"-"` - означает, что поле не будет сериализовано

---
### Zero-links:
[[00 Backend]] [[00 Golang]]

---
### Links:
[[Пользовательские типы в Go]]