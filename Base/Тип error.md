30.09.2024 23:46
Tags: #info

---
# Тип error

Тип `error` — это интерфейсный тип:

```
type error interface {
    Error() string //  Этот метод должен возвращать текст ошибки. 
} 
```

Благодаря тому, что функции могут возвращать несколько значений, ошибки легко попадают в их ряды. Использование `error` в последнем возвращаемом значении функции — очень распространённый в Go паттерн. Если возвращаемое значение ошибки равно `nil`, то функция завершилась корректно. В противном случае остальные значения функции использовать нельзя и нужно обработать ошибку.

Рассмотрим пример:

```go
if data, err := os.ReadFile(`nothing.txt`); err != nil {
    // будет вызван метод 'Error() string', который преобразует ошибку в строку
    fmt.Println(err)
} else {
    fmt.Println(string(data))
}
```

Обычно в Go используется паттерн «ранний выход», поэтому код выше лучше использовать так:
```go
func ReadTextFile() (string,error) {
    data, err := os.ReadFile(`nothing.txt`)
    if err != nil {
        // будет вызван метод 'Error() string', который преобразует ошибку в строку
        fmt.Println(err)
        return "", err
    } 
    fmt.Println(string(data))
    return string(data), nil
    
}
```

С помощью такого способа не происходит замусоривания кода лишними `else`.

Если запустить такой код с отсутствующим файлом `nothing.txt`, программа выведет `open nothing.txt: no such file or directory`. Возвращаемое значение `data` никак не обрабатывается.

В стандартной библиотеке Go есть пакет `errors` для работы с ошибками. Чтобы создать переменную типа `error`, нужно вызвать функцию `New`, которая принимает в параметре строку. Например, в коде выше можем создать собственную ошибку, а не возвращать полученную из функции.
```go
func ReadTextFile()  (string, error) {
	data, err := os.ReadFile(`nothing.txt`)
    if err != nil {
        // будет вызван метод 'Error() string', который преобразует ошибку в строку
        fmt.Println(err)
        return "", errors.New("some_file_process_func: read file error")
    }
    fmt.Println(string(data))
    return string(data), nil

}
```

Однако такой подход имеет свои недостатки. В пакете несколько функций могут возвращать одинаковые ошибки. Кроме того, вызов функции формирования ошибки будет происходить каждый раз при её использовании, и переменная ошибки будет пересоздаваться многократно, более того, если кто-то будет использовать вашу библиотеку, он не сможет проверить возвращаемую ошибку.

Поэтому наиболее часто используется создание ошибок статически, на этапе инициализации модуля:

```go
// Статически создаем ошибку.
var ErrFileReading = errors.New("read_text_file: read file error") //  хорошей практикой является начинать текст ошибки с названия пакета, где она объявлена, так будет проще найти ее

func ReadTextFile() (string, error) {
    data, err := os.ReadFile(`nothing.txt`)
    if err != nil {
        // будет вызван метод 'Error() string', который преобразует ошибку в строку
        fmt.Println(err)
        return "", ErrFileReading
    }   
    fmt.Println(string(data))
    return string(data), nil
}
```

Если нужно сформировать ошибку с использованием дополнительной информации, можно применять функцию `fmt.Errorf`, которая работает как `fmt.Sprintf`, но возвращает вместо строки ошибку. В Go принято начинать текст ошибок со строчной буквы, так как ошибки могут объединяться друг с другом.

```go
func ReadTextFileByName(filename string) (string, error) {
    data, err := os.ReadFile(filename)
    if err != nil {
        // вернём ошибку на русском языке
        return ``, fmt.Errorf(`не удалось прочитать файл (%s): %v`, filename, err)
    }
    return string(data), nil
}
```

---
### Zero-links:
[[00 Backend]] [[00 Golang]]

---
### Links:
[[Ошибки]]