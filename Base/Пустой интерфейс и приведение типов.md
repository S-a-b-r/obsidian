11.09.2024 23:55
Tags: #info

---
# Пустой интерфейс и приведение типов
Бывают ситуации, когда не всегда можно указать конкретные типы переменных. Например, если получаем JSON-документ от пользователя, то структура этого документа может быть любой.
Разрешить функции произвольный параметр можно с помощью пустого интерфейса - `interface{}`. Однако использовать переменную типа пустого интерфейса невозможно.
```go
func PassAnyType(v interface{}) {
    // ...
}
```
В Go 1.18 у типа `interface{}` появился более короткий псевдоним - `any`

Возвращаясь к переменной `v`. Для какого-либо взаимодействия с ней необходимо привести ее к какому-либо типу оператором `v.(type)`
Оператор приведения типа приводит переменную интерфейсного типа к конкретному типу или другому интерфейсу:
```go
func PassAnyType(v interface{}) {
    i := v.(int)     // если v не число, то будет паника, то есть программа не сможет работать и прекратит выполнение

    i, ok := v.(int) // альтернативный формат: если v не число, то будет false
                     // паники не будет 
    if ok {
        // ...
    }
}
```
Второй вариант более предпочтителен. Также хорошей практикой является Защита типа с помощью оператора `switch`:
```go
func Printf(v interface{}) {
    switch v2 := v.(type) {
    case int:
        fmt.Print("Это число " + strconv.FormatInt(v2, 10))
    case string:
        fmt.Print("Это строка " + v2)
    case Stringer:
        fmt.Print("Это тип, реализующий Stringer, " + v2.String())
    default:
        fmt.Print("Неизвестный тип")
    }
}
```

## Внтурненнее устройство интерфейсов
Чтобы понять, каким образом интерфейсы приводятся к другим типам, следует разобраться, как устроен интерфейс изнутри.
```go
type User struct {
    Email      string
    Password   string
    LastAccess time.Time
}

func (u User) String() string {
    return "user with email " + u.Email
}

func Printf(v Stringer) {
    fmt.Print("Это тип, реализующий Stringer, " + v.String())
}

func main() {
    u := User{Email: "example@yandex.ru"}
    Printf(u)
}
```
Вот такие данные будут храниться в переменной `v Stringer`:

![[Pasted image 20240915175544.png]]
То, что изображено на схеме, можно посмотреть подробнее в [src/runtime/runtime2.go](https://github.com/golang/go/blob/3b304ce7fe35b9d1e8cf0b0518ed2550c361a010/src/runtime/runtime2.go#L202).

На схеме видно, что интерфейс состоит из двух указателей: на метаданные типа и на сами данные. При приведении типа используются эти метаданные, чтобы вычислить, какой конкретный тип представляет этот интерфейс и как правильно разыменовать указатель на данные.

Почему так устроено? Всё дело в том, что переменной интерфейсного типа могут быть присвоены данные разного размера. Например, интерфейсу `Stringer` может удовлетворять и большая сложная структура, и пользовательский `int`. Поэтому сохраняем данные по указателю. А вот в `itable` храним метаинформацию о типе, который там содержится.

Когда присваиваем переменную конкретного типа, происходит следующее:
```go
// Компилятор создаёт в программе метаданные со списком методов интерфейса
type Stringer interface {
    String() string
}

// Компилятор создаёт в памяти структуру с описанием типа User, его полей
type User struct {
    
} 

var user Stringer // Объявляется переменная интерфейса — её значение пока что равно nil, в памяти выделяется два машинных слова под указатели tab и data  

// Переменной присваивается конкретное значение. Проверяется, удовлетворяет ли тип переменной интерфейсу. 
// При этом в tab записывается указатель на структуру itable, связывающий информацию о типе User и Stringer,
// а в data — указатель на User{}
user := User{}

// Интересно, что связывание типа и интерфейса происходит не на этапе компиляции, иначе размер программы был бы слишком большим, а на этапе выполнения. Эта операция кешируется, так что выполняется всего один раз и не влияет на производительность.

// Проверяем, что в tab у нас лежит действительно тип User — и если да, то ok true, а в переменную u копируется значение data.   
// Если типы не совпадают, то ok — false
u, ok := user.(User)

```

Интерфейсная переменная по природе относится к ссылочному типу. Если передать её в функцию, то она скопируется, но, так как указатели будут указывать на ту же исходную переменную, изменение переменной через вызов методов может изменить данные.

В Go есть особенность, связанная с `nil`. Посмотрите ещё раз на схему: интерфейс может быть `nil`, а может быть с `nil`-указателем на данные. Покажем пример, где эта особенность приводит к ошибке:

```go
// Собственный тип для ошибок. Аналогичен стандартному error
type Error interface {
    Error() string
}

// MyError — структура, реализующая нашу ошибку
type MyError struct {
    // ...
}

// Error — метод для удовлетворения интерфейсу Error
func (e *MyError) Error() string {
    return "..."
}


// переменная типа ошибки — указатель на пустую структуру
var ErrFriday13 = &MyError{}

func CheckTodayIsOkay() Error {
    var err *MyError // указатель на переменную типа Error
    // получаем текущее время
    t := time.Now()
    // если день недели пятница и число месяца 13, то вернём ошибку  
    if t.Weekday() == time.Friday && t.Day() == 13 {
        err = ErrFriday13
    }
    // вернём ошибку ... указатель же nil
    return err
}

func main() {
    err := CheckTodayIsOkay()
    // проверяем err на nil — и внезапно всегда не nil 
    if err != nil {
        fmt.Println("error is not nil")
        return
    }

    fmt.Println("error is nil")
}
```
Код выведет строчку `"error is not nil"`, потому что Go обернёт `nil`-указатель `*MyError` в не-`nil`-интерфейс `Error`.  
То есть мы присвоили переменной типа `interface{}` переменную определённого типа. Это значит, что метаданные непустые, а значит и nil-у не равны.

Исправить проблему можно так:

```go
func CheckTodayIsOkay() Error {
    var err Error

    t := time.Now()
    if t.Weekday() == time.Friday && t.Day() == 13 {
        err = ErrFriday13
    }

    return err
}
```
В этом случае код выведет строчку `"error is nil"`, потому что сам интерфейс `Error` будет `nil`.




---
### Zero-links:
[[00 Backend]] [[00 Golang]]

---
### Links:
[[Интерфейсы]]