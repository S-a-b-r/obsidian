01.10.2024 00:22
Tags: #info

---
# Сравнение и обертывание ошибок
Практически любая функция может вернуть разные ошибки. Хотелось бы уметь их анализировать и понимать, что происходит, для последующей работы. Например, база данных может возвращать ошибку `NoRows`, если искомые данные не найдены, однако это не всегда является нарушением логики работы программы.

Ошибки можно сравнивать так же, как и другие переменные:
```go
data, err := ReadTextFile()
// Проверяем, что была возвращена ошибка
if err != nil {
    if err == ErrFileReading {
        fmt.Println("unable read file")
        return 
    }
    fmt.Println("unknown error")
    return
}

```

Однако, нельзя сравнивать ошибку ни с чем, кроме как с `nil`, если она была сформирована динамически.

## Обёртывание ошибок
Существует два подхода к созданию ошибок: статический и динамический. Оба подхода имеют недостатки.

*Статические* ошибки быстро обрабатываются и легко читаются, их просто сравнивать, но они теряют гибкость, если нужно добавить в ошибку дополнительную информацию.

*Динамические* ошибки создаются в процессе работы программы, они более медленные и их трудно сравнивать, но они дают большую гибкость.

Начиная с версии Go 1.13 имеется возможность "упаковывать" или "обертывать" ошибки (Wrapping error).

Это означает, что можно создавать новую ошибку поверх старой, но сохранять возможность восстановить оригинальную ошибку. Это может понадобиться для создания собственных типов ошибок на основе уже существующих. Ниже приводится пример.

Разберем пример с чтением файла:
```go
func ReadTextFile(filename string) (string, error) {
    data, err := os.ReadFile(filename)
    if err != nil {
        // возвратим ошибку на русском языке
        return "", fmt.Errorf(`не удалось прочитать файл (%s): %w`, filename, err)
    }
    return string(data), nil
}
```

В этом случае можно восстановить оригинальную ошибку, используя функцию `errors.Unwrap`, и добавить дополнительные проверки.

Кроме того, в пакете `github.com/pkg/errors` есть функции `Wrap` и `Wrapf`, которые создают обёрнутую ошибку.

Для чего нужно оборачивать ошибки? Дело в том, что с помощью обёртывания можно создать некоторую иерархию ошибок:

```go
// Статически создаём ошибку.
var ErrFileReading = errors.New("read_text_file: read file error") 

func ReadTextFileByName(filename string) (string, error) {
    if data, err := os.ReadFile(filename); err != nil {
        // будет вызван метод 'Error() string', который преобразует ошибку в строку
        fmt.Println(err)
        return errors.Wrapf(ErrFileReading, "file not exist %s", filename)
    }   
    fmt.Println(string(data))
    return string(data), nil
}
```

Остается в месте вызова функции проверить нашу ошибку:

```go
data, err := ReadTextFileByName("test.txt")
if errors.Is(err, ErrFileReading) {
    // что-то делаем
}
```
Функция `Is` сравнивает ошибки, причём даже обёрнутые! Благодаря этому можно обрабатывать обёрнутые ошибки и передавать в них какую-то дополнительную информацию.

Хорошим тоном для архитектуры считается, чтобы пакет возвращал только свои ошибки. Набор ошибок пакета является частью контракта по работе с ним. Пробрасывая полученные ошибки из других пакетов, увеличиваем связность пакетов. Ведь тогда стороне, обрабатывающей ошибки, придётся обрабатывать не только ошибки нашего пакета, но и пакетов, от которых зависим.

---
### Zero-links:
[[00 Backend]] [[00 Golang]]

---
### Links:
[[Ошибки]] [[Тип error]]