25.06.2024 18:41
Tags: #info

---
# Мапы
По сути, ассоциативный массив, представляющий из себя пару ключ - значение.
Адреса значения для ключа, как правило, вычилсяется хеш-функцией, поэтому такую структуру данных еще называют хеш-таблицей.

```go
m := make(map[string]string)
m["foo"] = "bar"
m["ping"] = "pong"        
fmt.Println(m)
```

Декларируется тип map так:
```go
var m map[KeyType]ValueType
```

В языке Go `map` — **ссылочный тип (reference type)**, поэтому одного объявления типа `map` недостаточно.

К примеру, такой код скомпилируется:
```go
var m map[string]string
m["foo"] = "bar" 
```

Но выдаст ошибку во время исполнения ([run-time panic](https://golang.org/ref/spec#Run_time_panics)):
```
panic: assignment to entry in nil map 
```

Поэтому используется функция make(): 
```go
type MyMap map[string] string

var m1 MyMap
m1 = make(MyMap, 5)

// объект готов
m1["foo"] = "bar"
```

Вторым аргументом тут передан предполагаемый размер мэпы(5 элементов). Поскольку выделение памяти для мэп работает также, как и для слайсов, нужно задумываться о предположительной размерности.

Также можно объявить мэп с помощью `Сложного литерала`:

```go
MyMap := map[KeyType]ValueType{key1: value1, key2: value2, ... , keyN: valueN,}
// например
MyStringMap := map[string]string{"first": "первый", "second": "второй",}
```

## Ограничения для типов ключей

Для ключей должны быть определены операторы `==` и `!=`, поэтому ключ не может быть функцией, хеш-таблицей или слайсом.


### Ньюанс
Если ключ не будет определен, то `map[key]` вернет нулевое значение того типа, которого хранит.
А как отличить нулевое значение, заданное `map[0] = 0` от Незаданного `map[0]`?
Для этого можно воспользоваться полной формой индексного выражения:
```go
v, ok = m[k]//ok=true, если ключ найден
```


Получить адрес элемента `map` не получится. Это связано с тем, что при добавлении новых элементов в мапу может произойти перемещение в памяти уже существующих элементов. Указатели на эти элементы станут недействительными. Поэтому такая операция запрещена.

Такой код
```go
addr := &m[k] 
```

вызовет ошибку компиляции:
```bash
cannot take the address of m[k] 
```


Map - потоконебезопасный тип, как и все, кроме `chan` в go. Отсюда следует, что для использования map должны использоваться механизмы защиты, иначе возможно повреждение данных. Но есть потокобезопасный варинт, эквивалент `map`. 
[Ссылка на него](https://golang.org/pkg/sync/#Map)

---
### Zero-links:
[[00 Backend]] [[00 Golang]]

---
### Links: