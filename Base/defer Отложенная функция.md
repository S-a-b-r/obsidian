10.07.2024 23:55
Tags: #info

---
# defer Отложенная функция
Defer - это оператор отложенного вызова. Используется, например, чтобы не забыть закрыть поток чтения файла.

```go
resource := System.Acquire("resourceID")
defer System.Close(resource)
```
Оператор `defer` используют внутри функции. Введем обозначения "Отложившая функция" - функция, внутри которой вызывается defer. "Отложенная" - функция, которую откладывает defer. 

Инструкция `defer` вычисляет аргументы для вызова, но вызов не делает. Вызов выполняется перед тем, как отложившая его функция вернет управление.

Работу оператора можно описать следующим образом.
1. Идёт обычное выполнение программы.
2. Наступает очередь выполнения оператора `defer`.
3. Вычисляются операнды отложенной функции, если такие есть.
4. Вызов функции вместе со значениями откладывается в специальный стек.
5. Выполнение функции продолжается. Если встречается оператор `defer`, то повторяем пункты 3 и 4.
6. Если встречается оператор `return`, то функция вычисляет его операнды и сохраняет значение в буфер.
7. Если стек отложенных вызовов не пустой, то извлекаем из него вызов функции и выполняем его.
8. Повторяем пункт 7, пока стек не опустеет.
9. Выходим из функции, возвращая значение из буфера.

Важно понимать, что результат функции вычисляется до выполнения отложенных вызовов.

Отложенных вызовов может быть несколько. Тогда они выполняются снизу вверх(т.к. лежат в стеке).

```go
fmt.Println("Hello")
for i := 1; i <= 3; i++ {
    defer fmt.Println(i)
}
fmt.Println("World")
```
Выведет 
```bash
Hello
World
3
2
1
```

Также отложенная функция может быть анонимной и заданной литерально. В таком случае ей могут быть доступны переменные отложившей функции и при изменении произойдет замыкание. Например, если у отложившей функции есть именованное возвращаемое значение, отложенная функция может его изменить.
```go
func unintuitive() (value string){
    defer func() {value = "На самом деле"}()
    return "Казалось бы"
}//Возвращает "На самом деле"
```
Внимание, это работает только с именованными возвращаемыми значениями. Следующий код выведет `"Казалось бы"`:
```go
func intuitive() (string){
    value := "Казалось бы"
    defer func() {value = "На самом деле"}()
    return value
}
```
В первом случае функция возвращает переменную `value`. При вычислении операнда `return` ей действительно присваивается значение `"Казалось бы"`, но эта переменная захвачена замыканием и изменяется в нём. После чего она и возвращается из функции.

Во втором случае у нас есть некоторая скрытая переменная `ret1`, в которую при вызове оператора `return` копируется значение её операнда. После любые действия с `value` уже не будут важны.

Также распространённой ошибкой является предположение, что операнды отложенной функции будут вычислены во время её выполнения. Это не так, они вычисляются при выполнении оператора `defer`:
```go
package main

import "fmt"

func main() {
    a := "some text"
    defer func(s string) {
        fmt.Println(s)
    }(a)
    a = "another text"
}
```
Программа напечатает `"some text"`.

### Пример применения:
Реализуем на основе функции `defer` замер времени выполнения функции.
Для начала создадим функцию, которая будет измерять время выполнения и выводить его на экран.
```go
    func metricTime (start time.Time) {
        // функция Now() возвращает текущее время, а функция Sub возвращает разницу между двумя временными метками
        fmt.Println(time.Now().Sub(start))
    } 
```

Теперь применим её внутри какой-нибудь функции.
```go
    func VeryLongTimeFunction () {
        defer     metricTime(time.Now()) // передаём в функцию metricTime значение текущего времени и откладываем её вызов до возврата
        // Какие-то долгие вычисления
    }
```



---
### Zero-links:
[[00 Backend]] [[00 Golang]]

---
### Links: