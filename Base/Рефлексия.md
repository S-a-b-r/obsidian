23.09.2024 17:46
Tags: #info

---
# Рефлексия
Рефлексией в программировании называют возможность получить информацию о типе из переменной этого типа. Проще говоря, рефлексия позволяет получить информацию о коде программы и менять его во время выполнения.

Рефлексия обычно используется для работы с данными, тип которых неизвестен при компиляции. Например, по сети могут приходить какие-то данные, которые должны быть уложены в структуры, но что это за данные наверняка узнать не получится.

Хоть в большинстве задач стоящих перед разработчиком рефлексия не применяется, но она используется в популярном пакете `encoding/json` и многих других.

Для работы с рефлексией в языке Go есть пакет `reflect` из стандартной библиотеки.

Функции пакета работают с произвольными статическими типами (`interface{}`) и позволяют получать метаинформацию о них. С помощью этого пакета можно динамически создавать типы в ходе выполнения приложения (в runtime).

## DeepEqual

Иногда возникает потребность сравнить две переменные одного типа по значению, и бывают случаи, что простой подход с использованием `==` не срабатывает. Тогда, чтобы заглянуть глубже, и сравнить значения лежащие в слайсах и мапах, а также под указателями используется `reflect.DeepEqual()`.

Рассмотрим на примере:
```go
type MyType struct {
    IntField   int
    StrField   string
    PtrField   *float64
}

func (mt MyType) IsEqual(mt2 MyType) bool {
    return mt == mt2
}

func main() {
    floatValue1, floatValue2 := 10.0, 10.0
    a := MyType{IntField: 1, StrField: "str", PtrField: &floatValue1}
    b := MyType{IntField: 1, StrField: "str", PtrField: &floatValue2}

    fmt.Printf("Равенство a и b: %v\n", a.IsEqual(b)) // false
}
```
Это происходит, потому что данное сравнение является сравнением указателей на структуры, которые, конечно, не равны. И только если оба указателя равны `nil` данный код сработает верно.

Более того, если изменить структуру `MyType`:
```go
type MyType struct {
    IntField   int
    StrField   string
    PtrField   *float64
    SliceField []int
}
```

То компиляция такого типа выведет ошибку, т.к. для типа SliceField не определена операция `==`. Это справедливо не только для структур, но и для всех пользовательских типов, например, `type MySlice []int`.

---
Одно из решений — изменить код метода `IsEqual` и добавить туда несколько `if`. Написание метода или функции сравнения — распространённая практика в Go, так как язык не позволяет перегружать операторы (`==` в данном случае).

---

Пакет `reflect` предлагает следующее решение:
```go
func (mt MyType) IsEqual(mt2 MyType) bool {
    return reflect.DeepEqual(mt, mt2)
}

func main() {
    floatValue1, floatValue2 := 10.0, 10.0
    a := MyType{IntField: 1, StrField: "str", PtrField: &floatValue1, SliceField: []int{1}}
    b := MyType{IntField: 1, StrField: "str", PtrField: &floatValue2, SliceField: []int{1}}

    fmt.Printf("Равенство a и b: %v\n", a.IsEqual(b)) // true
}
```

Функция сравнивает значения всех элементов типа, включая вложенные. [Документация](https://golang.org/pkg/reflect/#DeepEqual)

На практике `DeepEqual` используется нечасто, так как вызов этой функции рекурсивно пробегает по всем элементам типа, на что уходит много времени процессора. Чаще всего `IsEqual` пишут вручную, ограничивая область сравнения требуемой логикой приложения.

`DeepEqual` позволяет сравнить две переменные одного типа по значению, даже если эти переменные имеют сложную структуру данных, например содержат ссылки на другие переменные.

---
### Zero-links:
[[00 Backend]] [[00 Golang]]

---
### Links: