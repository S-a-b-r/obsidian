07.09.2024 12:15
Tags: #info

---
# Интерфейсы
По своей сути интерфейс - контракт, который описывает, что должен реализовывать тип, реализующий интерфейс. В Go есть ньюанс с так называемой утиной типизацией. Т.е. напрямую не надо имплементировать интерфейс в классы, компилятор сам поймет, что тип реализует какой-либо интерфейс.

Обрати внимание, что интерфейс является типом.

Пример объявления интерфейса:
```go
type MyInterface interface {
    Method1(int) int
    Method2(a string) string 
    //.... может быть ещё много методов
}
```
В фигурных скобках указывается имя метода, список его аргументов и возвращаемых значений. Названия аргументов могут быть опущены, поэтому достаточно указать тип. Но для лучшего понимания кода их лучше писать: описание метода `Create(id int, name string, email string) bool` более понятно, чем `Create(int, string, string) bool`, хотя формально эти методы идентичны

Основное назначение интерфейсов — реализация полиморфизма: с одной стороны, тип может реализовывать несколько интерфейсов в разных контекстах применения, с другой стороны, у нас есть возможность написания алгоритмов, работающих с разными типами данных.

Приведём простой пример. Представим, что у нас есть некоторая структура `Person`, описывающая человека. В различных областях жизни (и нашей программы) человек может выступать в разных ролях: например, быть студентом, работником, родителем и кем-нибудь ещё. Для конкретной области не имеет значения, кем он является в других. На работе от него ждут работы, в обучении — сдачи домашних работ. Как родитель он может сообщить информацию о детях. А ещё он может сообщать информацию о себе.

Опишем эти отношения в коде:

```go
package person

// Person - структура, описывающая человека
type Person struct {
    name string
    homework string
    children []*Person
}

// DoHomework — делает домашнюю работу 
func (p Person) DoHomework() string {
    return p.homework
}

// Children — сообщает информацию о детях
func (p Person) Children() []*Person {
    return p.children
}
 
// Work — выполняет поручения на работе
func (p Person) Work( tasks []string ) string {
    s := p.name + " work:"
    for _,task :=  range tasks {
        s += "\n I do " + task    
    }   
    return s
}

// String — сообщает информацию о себе
func (p Person) String() string {
    return p.name
}
```

Естественно, не требуется одновременное наличие этих методов в разных участках программы. Более того, их вызов может нарушить нормальную работу программы.

Давайте опишем другой пакет:
```go
package company

// Worker — интерфейс работника компании 
type Worker interface {
    // всё, что он должен уметь делать, — это работать
    Work(tasks []string) string
}

// Company — структура компании 
type Company struct {
    // personal — сотрудники компании
    // обратите внимание, мы создали слайс сотрудников компании, то есть слайс переменных интерфейсного типа Worker
    personal [] Worker
}

// Hire — наём нового сотрудника
// Сотрудник может быть любого типа: человек, робот или сторожевая собака. Главное, чтобы он умел работать, то есть удовлетворял интерфейсу Worker
// Go ещё на этапе компиляции проверяет, соответствует ли интерфейсу переданная переменная
func (с* Company) Hire( newbie Worker ) {
    с.personal = append(с.personal, newbie) 
}

// Process — работа конкретного сотрудника 
func (с Company) Process ( id int,  tasks []string) (res string) {
    return c.personal[id].Work(tasks)
}
```

Собственно, уже на данном этапе структура `person` реализует интерфейс `worker` за счет [[Структурная типизация(Утиная типизация)]].
В этом и заключается суть полиморфизма, что `company` может работать с разными сущностями, по-разному реализующими интерфейс `worker` 

Теперь соединим эти пакеты вместе.
```go
package main

import (
    "company"
    "person"
)

func main() {
    pers := person.Person{}
    comp := company.Company{}
    
    comp.Hire(pers) // мы передаём переменную типа Person в функцию, аргументом которой является переменная Worker! 
}
```
На этапе компиляции компилятор проверяет, можно ли `person` присвоить переменной типа `Worker`. Для этого проверяется, что тип `Person` имеет все методы интерфейса `Worker`. В нашем случае они есть, всё работает.

C помощью интерфейсов можно написать код, абстрагированный от внешних модулей: при изменениях в них ничего не нужно переделывать в своём коде, и наоборот.

Интерфейсы добавляют гибкости и снижают связность кода. Пакеты `person` и `company` ничего не знают друг о друге, но могут успешно взаимодействовать.

Продолжим рассматривать наш пример.

Предположим, что мы решили добавить в нашу программу роботов, которые могут работать так же, как и люди:
```go
package robot

import "fmt"

// Robot — тип робота
type Robot struct {
    model       string
    serialId    int
    workCounter int
}

func (r Robot) String() string {
    return fmt.Sprintf("Robot %s serialID %d", r.model, r.serialId)
}

// Work — робот выполняет работы и запоминает количество выполненных задач. Поэтому получатель метода — по указателю
func (r *Robot) Work(tasks []string) string {
    res := fmt.Sprintf("%s work:", r)
    for _, task := range tasks {
        res += "\n I do " + task
    }
    r.workCounter += len(tasks)
    return res
}
```
Теперь компания без проблем наймет робота

---
**Важно**
С точки зрения Go типы `Robot` и `*Robot` (указатель) — разные. В примере метод `Work` привязан именно к `*Robot`. Так как формально тип `Robot` не реализует интерфейс `Worker`, такой код не скомпилируется:

```go
comp := company.Company{}

robo := Robot{};
comp.Hire(robo); 
```
---

## Интерфейсы должны быть компактными

В Go принято делать интерфейсы по возможности маленькими. Чем проще интерфейс, тем легче воспринимать код. Если в интерфейсе больше 5–10 методов, значит, пора его делить.

Хорошая практика — объявлять интерфейс даже с одним методом. Часто такие интерфейсы:
```go
type Stringer interface {
    String() string
}
```

---
### Zero-links:
[[00 Backend]] [[00 Golang]][[00 ООП]]

---
### Links:
[[ООП в Go]]