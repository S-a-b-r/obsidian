05.09.2024 20:59
Tags: #info

---
# Эмбеддинг (embedding types)
Прямого наследования в golang нет, зато есть такое понятие, как встраивание типов. Структуры могут включать в себя другие структуры и типы.
Рассматривая на примере:
```go
type OuterStruct struct {
	EmbeddedType
	A int
	B int
}
```

Все поля и методы EmbeddedType будут переданы в структуру OuterStruct, как если бы она сама их содержала. Это позволяет переиспользовать код сложных структур, встраивая одни в другие.

Рассмотрим на примере двух структур `person` и `student`. Это похоже на наследование, но есть существенные различия. Структура `student` не является `person`. И отсюда следует, что объект `student` не может быть приведен к типу `person`.  Условно говоря, нет такой конструкции как `person := Student(person)` для встроенных типов нет.
```go
package main

import (
    "fmt"
)

// Person — структура, описывающая человека.
type Person struct {
    Name string
    Year int
}

// NewPerson возвращает новую структуру Person.
func NewPerson(name string, year int) Person {
    return Person{
        Name: name,
        Year: year,
    }
}

// String возвращает информацию о человеке.
func (p Person) String() string {
    return fmt.Sprintf("Имя: %s, Год рождения: %d", p.Name, p.Year)
}

// Print выводит информацию о человеке.
func (p Person) Print() {
    // вызовется метод String() для Person 
    fmt.Println(p)
}

// Student описывает студента с использованием вложенной структуры Person. То есть структура Student описывает.  
type Student struct {
    Person // вложенный объект Person
    Group  string
}

func NewStudent(name string, year int, group string) Student {
    return Student{
        Person: NewPerson(name, year), // Явно создаём структуру Person 
        Group:  group,
    }
}

// String возвращает информацию о студенте. 
func (s Student) String() string {
    return fmt.Sprintf("%s, Группа: %s", s.Person, s.Group)
}

func main() {
    s := NewStudent("John Doe", 1980, "701")
    s.Print()
    // вызовется метод String() для Student
    fmt.Println(s)
    fmt.Println(s.Name, s.Year, s.Group)
	// Имя: John Doe, Год рождения: 1980
	// Имя: John Doe, Год рождения: 1980, Группа: 701
	// John Doe 1980 701
}
```

## Доступ к полям вложенных структур

Если вложенный тип описан в другом пакете, то встраивающий его тип имеет доступ только к экспортируемым(публичным) методам и полям. Есть несколько способов обеспечить доступ к полям вложенных структур. Добавим метод `Debug()` для типа `Student`:
```go
func (s *Student) Debug() {
    // доступ к методам объекта Person
    s.Print()
    // или
    s.Person.Print()

    // доступ к полю 'Name' объекта Person
    s.Name = "Mark Smith"
    // или
    s.Person.Name = "Mark Smith"

    // вызовется метод String объекта Student
    fmt.Println(s)
    // вызовется метод String объекта Person
    fmt.Println(s.Person)
}
```

Для метода `String()` обращение `s.String()` - вызовет метод структуры студент. Для переопределенных методов нужно обращаться напрямую - `s.Person.String()`

Фактически структура имеет поле с именем, совпадающим с именем типа. Однако при вызове метода вложенной структуры в неё передаётся не переменная, которая её вызвала, а это поле. При необходимости можно явно обратиться к методу вложенной структуры

Еще один ньюанс заключается в множественном встраивании, например, добавив следующий код к предыдущему примеру:

```go
    type Faculty string

    func (f Faculty) String() string {
        return string(f)    
    }

    func (f Faculty) Print() { 
        fmt.Println(f)
    }


    type Student struct {
        Person 
        Faculty
        Group  string
    }
    
    func main {
    //    s.Print()  
        fmt.Println(s)
    }
```

Если в примере выше расскомментировать строку `s.Print()`, то получим ошибку компиляции. `ambiguous selector s.Print` компилятор не может определить точно, пытается сообразить, какой же метод выбрать от `Faculty` или от `Person`. И выдает ошибку. При этом метод `String()`, который вызывается в `Println()`, скрывает все методы `String()` у вложенных типов. И ошибки не возникает.

Следует отменить, что эти же правила действуют не только для методов, но и для полей структур.

Можно переписать пример без использования вложенных структур и работать с нужными объектами, как с обычными полями:
```go
type Student struct {
    Person Person
    Group  string
}
```

### Встраивание указателей на тип
В структуру может быть встроен указатель на тип. Рассмотрим на примере
```go
    type Student struct {
        *Person
        Group  string  
    }
```

Внешние отличия небольшие, но встраивание указателя может быть удобно, если вы встраиваете в вашу структуру какую-то большую структуру и затем передаёте её по значению. Это может повысить производительность за счёт того, что копируется не вся структура, а только указатель на неё. Важно отметить, что в таком случае встроенная структура может быть изменена:
```go
    // принимает структуру по значению
    func ChangeName( s Student, name string) {
        s.Name = name
    }

    s := Student{&Person{Name: "alex"}, "021"}
    ChangeName(s, "teodor")
    fmt.Println(s.Name) // "teodor"
```

## Ограничения на встроенные типы

Согласно спецификации Go, не все типы данных могут быть встроены в структуры. Могут быть встроены типы или указатели на типы. При этом, если встраивается указатель на тип, то сам тип не может быть указателем. То есть можно встроить, например, тип `Person` и тип `*Person`, но нельзя встроить тип `**Person`.

## Применение

Ещё одно применение встраивания — это расширение возможностей внешних типов. Хочется иметь все возможности, которые представляет тип, находящийся во внешнем пакете, но не можем изменить сам пакет. В таком случае можно создать свой тип, встроить в него внешний и добавить необходимые методы и поля. Полученный тип будет содержать методы встроенного типа.

Часто разработчики библиотек предполагают, что предоставляемый библиотекой тип будет встраиваться в структуру пользователя, а не использоваться самостоятельно. В дальнейшем в нашем курсе вы познакомитесь с такими библиотеками.

---
### Zero-links:
[[00 Backend]] [[00 Golang]] [[00 ООП]]

---
### Links:
[[ООП в Go]]  [[Наследование]]